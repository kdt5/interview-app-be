generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "mysql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/// 사용자 정보를 저장하는 모델
model User {
  id             Int                  @id @default(autoincrement())
  nickname       String               @unique @db.VarChar(50)
  email          String               @unique @db.VarChar(254)
  password       String               @db.VarChar(60)
  createdAt      DateTime             @default(now()) @map("created_at")
  updatedAt      DateTime             @default(now()) @updatedAt @map("updated_at")
  answers        Answer[]
  comments       CommunityComment[]
  favorites      Favorite[]
  refreshTokens  RefreshToken[]
  resetTokens    PasswordResetToken[]
  Position       Position?            @relation(fields: [positionId], references: [id])
  positionId     Int?                 @map("position_id")
  communityPosts CommunityPost[]
  reports Report[]

  @@index([positionId], map: "User_position_id_fkey")
}

/// 질문 정보를 저장하는 모델
model Question {
  /// 고유 식별자
  id             Int                @id @default(autoincrement())
  /// 질문 제목
  title          String
  /// 질문 내용
  content        String             @db.Text
  /// 주간 질문 여부
  isWeekly       Boolean            @default(false) @map("is_weekly")
  /// 질문 작성일
  createdAt      DateTime           @default(now()) @map("created_at")
  /// 질문에 달린 답변들
  answers        Answer[]
  /// 질문을 즐겨찾기한 정보
  favorites      Favorite[]
  /// 질문과 연관된 카테고리들
  categories     QuestionCategory[]
  /// 주간 질문과의 관계 (One-to-One)
  weeklyQuestion WeeklyQuestion?
}

/// 주간 질문을 저장하는 모델
model WeeklyQuestion {
  /// 고유 식별자
  questionId Int      @id @map("question_id")
  /// 질문의 주간 질문 시작일
  startDate  DateTime @unique
  /// 관계 설정 (Foreign Key)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

/// 답변 정보를 저장하는 모델
model Answer {
  /// 고유 식별자
  id         Int      @id @default(autoincrement())
  /// 답변 내용
  content    String   @db.Text
  /// 답변 작성일
  createdAt  DateTime @default(now()) @map("created_at")
  /// 답변 수정일
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")
  /// 답변 작성자 정보
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// 답변 작성자 ID
  userId     Int      @map("user_id")
  /// 답변이 달린 질문 정보
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId Int      @map("question_id")

  @@index([questionId])
  @@index([userId], map: "Answer_user_id_fkey")
}

/// 커뮤니티 게시글을 저장하는 모델
model CommunityPost {
  id        Int                @id @default(autoincrement())
  title     String
  content   String             @db.Text
  createdAt DateTime           @default(now()) @map("created_at")
  updatedAt DateTime           @default(now()) @map("updated_at")
  userId    Int                @map("user_id")
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments  CommunityComment[]

  @@index([userId], map: "CommunityPost_user_id_fkey")
}

model CommunityComment {
  id        Int                @id @default(autoincrement())
  content   String             @db.Text
  createdAt DateTime           @default(now()) @map("created_at")
  updatedAt DateTime           @default(now()) @updatedAt @map("updated_at")
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int                @map("user_id")
  post      CommunityPost      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int                @map("post_id")
  parent    CommunityComment?  @relation("Parent", fields: [parentId], references: [id])
  parentId  Int?               @map("parent_id")
  children  CommunityComment[] @relation("Parent")
  isDeleted Boolean            @default(false) @map("is_deleted")

  @@index([postId], map: "Comment_post_id_fkey")
  @@index([userId], map: "Comment_user_id_fkey")
  @@map("Comment")
}

/// 신고된 게시글 및 댓글을 저장하는 모델
model Report {
  id  Int @id @default(autoincrement())
  reporter  User  @relation(fields: [reporterId], references: [id])
  reporterId Int @map("user_id")
  targetType  ReportTargetType  @map("target_type")
  targetId  Int @map("target_id")
  reason  String
  status  ReportStatus  @default(PENDING)
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([reporterId])
  @@index([targetType, targetId])
  @@index([status])
}

/// 신고된 대상의 종류
enum ReportTargetType {
  POST
  COMMENT
}

/// 신고된 대상의 처리 상태
enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
}

/// 즐겨찾기 정보를 저장하는 모델
model Favorite {
  /// 고유 식별자
  id         Int      @id @default(autoincrement())
  /// 즐겨찾기한 사용자 정보
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// 사용자 ID
  userId     Int      @map("user_id")
  /// 즐겨찾기된 질문 정보
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  /// 질문 ID
  questionId Int      @map("question_id")
  /// 즐겨찾기 생성일
  createdAt  DateTime @default(now()) @map("created_at")

  @@unique([userId, questionId])
  @@index([userId, questionId])
  @@index([questionId], map: "Favorite_question_id_fkey")
}

/// 카테고리 정보를 저장하는 모델
model Category {
  /// 고유 식별자
  id         Int                @id @default(autoincrement())
  /// 카테고리 이름
  name       String
  /// 카테고리 포지션 ID
  positionId Int                @map("position_id")
  /// 카테고리와 연관된 질문들
  questions  QuestionCategory[]
  /// Position과의 관계 설정
  position   Position           @relation(fields: [positionId], references: [id])

  @@index([positionId])
}

/// 질문과 카테고리의 다대다 관계를 저장하는 모델
model QuestionCategory {
  /// 질문 정보
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  /// 질문 ID
  questionId Int      @map("question_id")
  /// 카테고리 정보
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  /// 카테고리 ID
  categoryId Int      @map("category_id")

  @@unique([questionId, categoryId])
  @@index([questionId, categoryId])
  @@index([categoryId], map: "QuestionCategory_category_id_fkey")
}

/// 리프레시 토큰 정보를 저장하는 모델
model RefreshToken {
  id          Int      @id @default(autoincrement())
  hashedToken String   @unique
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int      @map("user_id")
  device      String?  @db.VarChar(255)

  @@index([userId])
  @@index([hashedToken])
}

/// 직무 정보를 저장하는 모델
model Position {
  id          Int        @id @default(autoincrement())
  code        String     @unique
  name        String
  description String?
  order       Int        @default(0)
  created_at  DateTime   @default(now())
  updated_at  DateTime   @default(now())
  categories  Category[]
  users       User[]
}

/// 비밀번호 재설정 토큰 정보를 저장하는 모델
model PasswordResetToken {
  id          Int      @id @default(autoincrement())
  hashedToken String   @unique
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int      @map("user_id")

  @@index([userId])
  @@index([hashedToken])
}
